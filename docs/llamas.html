<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Scala-Intro</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/blood.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

## What a Wonderful Day for Scala

We're going to learn:
- Case Classes
- Companion/Singleton Objects
- (Sealed)Traits
</script></section><section  data-markdown><script type="text/template">
## You've been hired!
![fab llama](assets/fab_llama.gif)

<aside class="notes"><p>You&#39;ve been hired by <em>The Llama Shaving Co</em></p>
<ul>
<li>Your boss has told you to create a Llama shaving simulator. You were once a lowly Java programmer, but he wants you to do it in <em>Scala!</em>. He wants it to be functional. Let&#39;s give it a shot.</li>
<li>As an OO programmer the first thing that comes to your mind is to build a class...and try to make it functional.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
You've been asked to...
</script></section><section  data-markdown><script type="text/template">
- Create a concept of a llama
</script></section><section  data-markdown><script type="text/template">
- It should store it's fluffyness somehow
  </script></section><section  data-markdown><script type="text/template">
- It should be able to be shaved, reducing it's fluffyness
</script></section><section  data-markdown><script type="text/template">
## Whiteboarding Time
</script></section><section  data-markdown><script type="text/template">
Basic class in Java:
```java
class Llama {}
```
</script></section><section  data-markdown><script type="text/template">
Basic Class in Scala:
```scala
class Llama
```

<aside class="notes"><p>This is all it takes to make a class in Scala. It doesn&#39;t do much.</p>
<ul>
<li>Haha wow this Scala thing is easy right...hahahaha
We need to measure fluffyness somehow!</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Adding a field in Java:
```java
class Llama {

  private int fluffyness;
  
  public Llama(int fluffyness) {
    this.fluffyness = fluffyness;
  }
  
}
```
</script></section><section  data-markdown><script type="text/template">
Adding a field in Scala:
```scala
class Llama(fluffyness: Int)
```

<aside class="notes"><p>This will do a few things:</p>
<ul>
<li>Add this as a required value to the class constructor</li>
<li>Save this as an immutable, private value within the class.
This is cool because it&#39;s so much less verbose than java!
Now, we need to actually change this value somehow. And do it functionally! As everything is immutable, you have to return a whole new Llama!</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Adding a method in Java:
```java
class Llama {

  private int fluffyness;
  
  public Llama(int fluffyness) {
    this.fluffyness = fluffyness;
  }
  
  public void shave(int woolAmt) {
    fluffyness = fluffyness - woolAmt;
  }
  
}
```
</script></section><section  data-markdown><script type="text/template">
Adding a method in Scala:
```scala
class Llama(fluffyness: Int) {
  
  def shave(woolAmt: Int): Unit {
    fluffyness = woolAmt - fluffyness
  }
  
}
```
> `Unit` is analogous to `void` in Java

<aside class="notes"><p>Now, let&#39;s add some logic to that method. Otherwise it doesn&#39;t do anything!
As the clueless OO programmer you are, you might write something verbose like this:</p>
</aside></script></section><section  data-markdown><script type="text/template">
Wait...that didn't work!
</script></section><section  data-markdown><script type="text/template">
That's because fluffyness is now immutable!
</script></section><section  data-markdown><script type="text/template">
Scala does this to ~~make your life hard~~ keep things functional.
 > All variables are immutable in FP

<aside class="notes"><p>Ask me this question at the end if we get time!</p>
</aside></script></section><section  data-markdown><script type="text/template">
Let's do that the long way:
```scala

class Llama(fluffyness: Int) {
  
  def shave(woolAmt: Int): Llama = {
    
    val newFluffiness = fluffyness - woolAmt
  
    val newLlama = new Llama(newFluffiness)
    
    return newLlama
  }
  
}
```
<aside class="notes"><p>This is a common pattern. So Scala has some nice syntactic sugar for doing this.</p>
</aside></script></section><section  data-markdown><script type="text/template">
Let's do this the short way:
```scala

class Llama(fluffyness: Int) {

  def shave(woolAmt: Int): Llama =
    new Llama(fluffyness - woolAmt)

}
```

<aside class="notes"><p>Lot&#39;s more syntactic sugar to come.
Okay let&#39;s go print this out and check everything works.</p>
<ul>
<li>You can see Scala is slightly shorter, but not all that much at the moment.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Let's recap so far:
 - We made a class with a field and method in both langauges
 - Scala had less boilerplate
 - Scala kept things functional
 </script></section><section  data-markdown><script type="text/template">
Onto the next step...
</script></section><section  data-markdown><script type="text/template">
## Mergers & Aquisitions
We have succeeded in our hostile takeover of *Llama Transport Co* in the Andes.

<aside class="notes"><p>Llamas are now sent on perilous journeys through the Andes. We need to track if they keep their fluffyness and strength!</p>
<ul>
<li>We are also more humane for better PR, and have given our llamas names.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
You've been asked you to...
</script></section><section  data-markdown><script type="text/template">
Add more fields:
- Update the `llama` class with `strength` and `name`
</script></section><section  data-markdown><script type="text/template">
Copy objects:
- Create a copy of a `llama` before they leave
</script></section><section  data-markdown><script type="text/template">
Check for equality:
- Ensure they are the same as their copy when they come back.
</script></section><section  data-markdown><script type="text/template">
Update our constructor and values in Java:
```java
class Llama {

  private int fluffyness;
  private int strength;
  private String name;
  
  public Llama(int fluffyness, int strength, String name) {
    this.fluffyness = fluffyness;
    this.strength = strength;
    this.name = name;
  }

  public void shave(int woolAmt) {
    fluffyness = fluffyness - woolAmt;
  }
  
}
```
</script></section><section  data-markdown><script type="text/template">
Update constructor and values in Scala:
```scala
class Llama(fluffyness: Int, strength: Int, name: String) {

  def shave(woolAmt: Int): Llama =
      new Llama(fluffyness - woolAmt)

}
```
</script></section><section  data-markdown><script type="text/template">
> Define copying and equality in Java

Extend the `clonable` interface:

```java
class Llama extends Clonable {

  final private int fluffyness;
  final private int strength;
  final private String name;
  
  public Llama(int fluffyness, int strength, String name) {
    this.fluffyness = fluffyness;
    this.strength = strength;
    this.name = name;
  }
  
}
```
</script></section><section  data-markdown><script type="text/template">
> Define copying and equality in Java

Implement `clone()` method:

```java
class Llama extends Clonable {

  @Override
  public clone() throws CloneNotSupportedException {
    return super.clone();
  } 
  
  final private int fluffyness;
  final private int strength;
  final private String name;
  
  public Llama(int fluffyness, int strength, String name) {
    this.fluffyness = fluffyness;
    this.strength = strength;
    this.name = name;
  }
  
}
```
</script></section><section  data-markdown><script type="text/template">
> Define copying and equality in Java

Then we would have to define `equals()` as well..

```java
class Llama extends Clonable {

  @Override
  public Llama clone() throws CloneNotSupportedException {
    return super.clone();
  }
  
  @Override
  public boolean equals(Object o) {
  
    // If the object is compared with itself then return true   
    if (o == this) { 
        return true; 
    } 

    /* Check if o is an instance of Llama or not 
      "null instanceof [type]" also returns false */
    if (!(o instanceof Llama)) { 
        return false; 
    } 
  
    // Typecast to llama
    Llama compareLlama = (Llama) o;
    
    return fluffyness == o.fluffyness && strength == o.strength && name == o.name);
    
  }
  
  final private int fluffyness;
  final private int strength;
  final private String name;
  
  public Llama(int fluffyness, int strength, String name) {
    this.fluffyness = fluffyness;
    this.strength = strength;
    this.name = name;
  }
}
```

<aside class="notes"><p>What a load of...work!</p>
</aside></script></section><section  data-markdown><script type="text/template">
Define copying and equality in Scala:
```scala
case class Llama(fluffyness: Int, strength: Int, name: String) {

  def shave(woolAmt: Int): Llama =
      new Llama(fluffyness - woolAmt)

}
```
</script></section><section  data-markdown><script type="text/template">
Cool. What is a case class?
</script></section><section  data-markdown><script type="text/template">
First, ignore the implications the title "case class"  gives you.
</script></section><section  data-markdown><script type="text/template">
It's just a package for data.
- You could think of it as:
  - A struct
  - JSON
</script></section><section  data-markdown><script type="text/template">
It gives you stuff you might want for data:
  + Syntactic sugar
  + Equality
  + Copying
  + HashCode
  + toString
  + Serialisable
  + Pattern matching
  + Algebraic Data Types
  </script></section><section  data-markdown><script type="text/template">
> Drawback of Case Class

Your compiled code is a little larger due to implementing all this.
</script></section><section  data-markdown><script type="text/template">
We generally don't store methods in here, in an attempt to keep thing more functional.
</script></section><section  data-markdown><script type="text/template">
So why are we doing all of this?
</script></section><section  data-markdown><script type="text/template">
Object orientated is a collection of objects: Each one a combination of data and functions.
</script></section><section  data-markdown><script type="text/template">
Functional programs are just a collection of functions which take data, manipulate it, and return it. Data is to be stored separately.

> This goes to the heart of functional programming
</script></section><section  data-markdown><script type="text/template">
This brings up a problem. What about the shave method? 
</script></section><section  data-markdown><script type="text/template">
## Companion Objects

<aside class="notes"><p>Like singleton objects, but attached to a class of some kind.</p>
<ul>
<li>Just change the name of the object to be the same as the class.</li>
<li>Whiteboard this up<ul>
<li>There exists only one object, never 0, never more than 1.</li>
<li>They are lazy loaded, so technically they don&#39;t exist before then, actually.</li>
</ul>
</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Declare an object:
```scala
case class Llama(fluffyness: Int, strength: Int, name: String)

object Llama 
```

<aside class="notes"><p>Now we can put it in the same file as our class and they hang out together.</p>
<ul>
<li>It has the same name as it&#39;s companion class</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Add the shave method:
```scala
case class Llama(fluffyness: Int, strength: Int, name: String)

object Llama {

  def shave(llama: Llama, woolAmt: Int): Llama =
    Llama.copy(fluffyness = llama.fluffyness - woolAmt)

}
```

<aside class="notes"><p>So now we have two nice and separate parts of the file - data and methods. Keeps it functional. But they are together in the same file, so it&#39;s still objects orientated as well.</p>
<ul>
<li>Let&#39;s review what we just did on the whiteboard: Show what these things look like in intellij, as well as in diagram form</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Why do that? Why not just have it in the class?
</script></section><section  data-markdown><script type="text/template">
`shave` now takes a llama as well. It is stateless.

It behaves in a static manner instead of like a method in OO.

<aside class="notes"><p>So what is that exactly?</p>
</aside></script></section><section  data-markdown><script type="text/template">
It has clearly defined immutable inputs and outputs in it's first line.

```scala
def shave(llama: Llama, woolAmt: Int): Llama = //...
```

<aside class="notes"><p>So how does that benefit us?</p>
</aside></script></section><section  data-markdown><script type="text/template">
In complex programs, this makes things easier to understand. All you need to know is the inputs and outputs.

> There are no external "global" variables it relies on.

<aside class="notes"><p>Global variables are kind of a good example here. 
If your function uses a global variables from <em>outside</em> the function then that&#39;s easy to miss.
Class variables can be a little like those global variables. They&#39;re <em>not</em> constant, even though they are immutable.
That&#39;s because there are many instances of that class.</p>
</aside></script></section><section  data-markdown><script type="text/template">
This makes testing and Test Driven Development easier as well.
</script></section><section  data-markdown><script type="text/template">
Let's recap.
</script></section><section  data-markdown><script type="text/template">
We implemented copy and equality in Java and Scala
> Scala saved on boilerplate with case class.
</script></section><section  data-markdown><script type="text/template">
We implemented case class and companion objects in Scala
> This made our code more functional, which brings a variety of benefits.
  </script></section><section  data-markdown><script type="text/template">
A few things to remember before we continue.
</script></section><section  data-markdown><script type="text/template">
There are benefits to both FP and OO/Imperative styles.

> Scala is flexible in that it allows both OO and FP.

This being good or bad is a matter of opinion.

<aside class="notes"><p>I personally believe it&#39;s good, my ideal program is a functional core, with a thin imperative shell to run it.</p>
<ul>
<li>Scala is still more object orientated than Haskell for example.</li>
<li>This has some benefits in being easier to integrate with other langauge as well<ul>
<li>Scala runs on the JVM</li>
<li>Scala runs Java code</li>
</ul>
</li>
<li>It can be argued that it&#39;s more object orientated than Java as well.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Objects in scala don't have to be companion objects.
> Singleton objects don't need no class.
</script></section><section  data-markdown><script type="text/template">
## Singleton Objects
</script></section><section  data-markdown><script type="text/template">
## Whiteboarding Time
</script></section><section  data-markdown><script type="text/template">
Example of a singleton object:
```scala
object DalaiLama {
  
  val HardCodedValue = 100
  
  def foo(bar: Int): Int = {
    bar - HardCodedValue 
  }
  
}
```

> There can only be one.
</script></section><section  data-markdown><script type="text/template">
Differences between singleton objects and companion objects:
 - Companion objects:
   - Are in the same file as their class
   - Have the same name as their class
</script></section><section  data-markdown><script type="text/template">
End part one. Kahoot?

> How are we doing for time?
</script></section><section  data-markdown><script type="text/template">
## Monetising the Llamas further
We have taken on a contract from a french fashion company to advertise hats.
</script></section><section  data-markdown><script type="text/template">
All llamas now have four types of Hats:
- Paris Hat
- Toulouse Hat
- Marseille Hat
- Nice Hat
</script></section><section  data-markdown><script type="text/template">
Each hat requires a trick when a traveller sees them:
- Paris Hat => Sit
- Toulouse Hat => Shake
- Marseille Hat => Talk
- Nice Hat => Triple backflip
</script></section><section  data-markdown><script type="text/template">
What your end result should like:
```
> println(llama.trick)
"Talk"
```
</script></section><section  data-markdown><script type="text/template">
Let's think about this...

<aside class="notes"><p>Let&#39;s use ADT</p>
<ul>
<li>Let&#39;s think about this...</li>
<li>The funciton needs to map each hat to a trick</li>
<li>A hat can come in four different flavours, but each llama <em>always</em> has a hat.</li>
<li>All llamas need to do tricks with their hat</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
All llamas *must* have hats, but a hat can come in four different flavours.
</script></section><section  data-markdown><script type="text/template">
There are a few different ways of doing this.
</script></section><section  data-markdown><script type="text/template">
Each Llama could store a string that describes the hat:
```scala
case class Llama (
  fluffyness: Int,
  strength: Int,
  name: String,
  hat: String
)
```
</script></section><section  data-markdown><script type="text/template">
Why is that bad?
</script></section><section  data-markdown><script type="text/template">
We could recieve any input, then...

> We would have a runtime error instead of a compile time error.
</script></section><section  data-markdown><script type="text/template">
How do we get a compile time error? 
> Enumerator?
</script></section><section  data-markdown><script type="text/template">
## Traits

<aside class="notes"><p>Like interfaces from Java.</p>
<ul>
<li>They are <code>extendable</code></li>
<li>They came with their own methods/fields and abstract methods if you want</li>
<li>But they are done a little more functionally</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Create a trait:
```scala
trait Hat
```

<aside class="notes"><p>Cool! We made a trait. Now lets do something with it.</p>
</aside></script></section><section  data-markdown><script type="text/template">
Extend the trait:
```scala
trait Hat

case object Paris extends Hat
case object Toulouse extends Hat
case object Marseille extends Hat
case object Nice extends Hat
```
</script></section><section  data-markdown><script type="text/template">
What is a case object?

<aside class="notes"><p>Woah! Case object? What is that?</p>
<ul>
<li>All the same things case does to class, we do to object.</li>
<li>But it&#39;s a little less. We don&#39;t need stuff like copy or equality, as there is only ever one.</li>
<li>Why not just object extends hat here?</li>
<li>We want to pattern match. Let&#39;s see that.</li>
<li>By the way. This is just an enumorator.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Let's go back to our llama class...

<aside class="notes"><p>We have now added hat as a value to llama.</p>
</aside></script></section><section  data-markdown><script type="text/template">
Pattern Matching:
```scala
object Llama {

  def trick(llama: Llama): String = {

    val trick = llama.hat match {
      case Paris => "Sit"
      case Toulouse => "Shake"
      case Marseille => "Talk"
      case Nice => "Triple backflip"
    }

    return trick
  }

}
```

<aside class="notes"><p>This is pattern matching. At the moment, this is the equivalent of making an enumorator, then creating a switch statement in Java.</p>
<ul>
<li>We can do better syntax.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Golfed:
```scala
def trick(llama: Llama): String = {
  
  llama.hat match {
    case Paris => "Sit"
    case Toulouse => "Shake"
    case Marseille => "Talk"
    case Nice => "Triple backflip"
  }
  
}
```

<aside class="notes"><p>This will just return that value that was declared into the damn void.</p>
<ul>
<li>In order for this pattern match to work, it would help if we <code>seal</code> our trait.</li>
</ul>
</aside></script></section><section  data-markdown><script type="text/template">
Seal our trait:
```scala
sealed trait Hat
```

<aside class="notes"><p>This means that no one can extend our trait outside of that file. It means the program is now confident that it has handled all possible cases of a hat in that pattern match.</p>
</aside></script></section><section  data-markdown><script type="text/template">
Turns out advertising hats in Andes mountain trails wasn't a great idea.

<aside class="notes"><p>Our french company has pulled it&#39;s sponsorship. What do we do with all these hats!</p>
</aside></script></section><section  data-markdown><script type="text/template">
We're pivoting to fruit hats.

<aside class="notes"><p>Llamas now carry fruit in their hats, for the llamas to eat.</p>
</aside></script></section><section  data-markdown><script type="text/template">
```scala
sealed trait Hat

case class Paris(numOfApples: Int) extends Hat
case class Toulouse(numOfApples: Int, numOfOranges: Int) extends Hat
case class Marseille(numofPizzas: Int) extends Hat
case object Nice extends Hat
```
</script></section><section  data-markdown><script type="text/template">
```scala
sealed trait Hat {

  def eatHat: Hat = this match {
    case Paris(numOfApples) => Paris(numOfApples - 1)
    case Toulouse(numOfApples, numOfOranges) => Toulouse(numOfApples - 1, numOfOranges - 1)
    case marseille @ Marseille(_) => marseille
    case Nice => Paris(5)
  }

}
```
</script></section><section  data-markdown><script type="text/template">
You're fired! We're switching back to object orientated, that was too hard.
</script></section><section  data-markdown><script type="text/template">
Questions!


</script></section></div>
    </div>

    <script src="./lib/js/head.min.js"></script>
    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"fade"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
